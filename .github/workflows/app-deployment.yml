name: Application Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      frontend_image_tag:
        description: "Frontend image tag"
        required: false
        default: latest
      backend_image_tag:
        description: "Backend image tag"
        required: false
        default: latest
      run_id:
        description: Terraform workflow run ID
        required: true
      app_repository:
        description: Application repository
        required: false
        default: pravinmishraaws/book-review-app
      app_branch:
        description: Application Repository Branch
        required: false
        default: main

env:
  AZURE_REGION: australiacentral
  FRONTEND_PATH: ./book-review-app/frontend
  BACKEND_PATH: ./book-review-app/backend
  K8S_PATH: ./k8s
  NAMESPACE: book-review-${{ github.event.inputs.environment }}
  

jobs:
  build-and-push-images:
    name: Build & Push Container Images
    runs-on: ubuntu-latest
    env:
      environment: ${{ github.event.inputs.environment }}

    outputs:
      acr-name: ${{ steps.get-infra.outputs.acr-name }}
      acr-login-server: ${{ steps.get-infra.outputs.acr-login-server }}
      aks-cluster-name: ${{ steps.get-infra.outputs.aks-cluster-name }}
      resource-group: ${{ steps.get-infra.outputs.resource-group }}
      mysql-fqdn: ${{ steps.get-infra.outputs.mysql-fqdn }}

    steps:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Checkout
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Checkout repository
      uses: actions/checkout@v4

   

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Download Terraform Outputs
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Download Terraform State
      uses: actions/download-artifact@v4
      with:
         name: terraform-state-${{ github.event.inputs.environment }}
         github-token: ${{ secrets.GITHUB_TOKEN }}
         run-id: ${{ github.event.inputs.run_id }}
         repository: ${{ github.repository }}

    - name: Fetch Application Code from Repository
      run: |
          APP_REPO="${{ github.event.inputs.app_repository || 'pravinmishraaws/book-review-app' }}"
          APP_BRANCH="${{ github.event.inputs.app_branch || 'main' }}"
          
          echo "ğŸ“¥ Fetching application code from repository..."
          echo "Repository: $APP_REPO"
          echo "Branch: $APP_BRANCH"
          
          # Clone the application repository
          git clone --branch $APP_BRANCH --depth 1 \
            https://github.com/$APP_REPO.git book-review-app
          
          echo "âœ… Application code fetched successfully"
          echo "ğŸ“ Directory structure:"
          ls -la book-review-app/

    - name: Verify Application Structure
      run: |
          echo "ğŸ” Verifying application structure..."
          
          if [ -d "${{ env.BACKEND_PATH }}" ]; then
            echo "âœ… Backend directory found"
            ls -la ${{ env.BACKEND_PATH }}/
          else
            echo "âš ï¸ Backend directory not found at ${{ env.BACKEND_PATH }}"
          fi
          
          if [ -d "${{ env.FRONTEND_PATH }}" ]; then
            echo "âœ… Frontend directory found"
            ls -la ${{ env.FRONTEND_PATH }}/
          else
            echo "âš ï¸ Frontend directory not found at ${{ env.FRONTEND_PATH }}"
          fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Extract Infrastructure Values
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Extract Infrastructure Details from Terraform
      id: get-infra
      run: |
          echo "ğŸ“‹ Extracting infrastructure details from Terraform outputs..."
          
          # Parse terraform outputs JSON
          ACR_NAME=$(jq -r '.acr_name.value' terraform-outputs.json)
          ACR_LOGIN_SERVER=$(jq -r '.acr_login_server.value' terraform-outputs.json)
          AKS_CLUSTER_NAME=$(jq -r '.aks_cluster_name.value' terraform-outputs.json)
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value' terraform-outputs.json)
          MYSQL_FQDN=$(jq -r '.mysql_fqdn.value' terraform-outputs.json)
          
          # Validate extracted values
          if [ -z "$ACR_NAME" ] || [ "$ACR_NAME" == "null" ]; then
            echo "âŒ Error: ACR name not found in Terraform outputs"
            exit 1
          fi
          
          # Export to outputs
          echo "acr-name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "aks-cluster-name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT
          
          echo "âœ… Infrastructure Details:"
          echo "  ACR: $ACR_NAME ($ACR_LOGIN_SERVER)"
          echo "  AKS: $AKS_CLUSTER_NAME"
          echo "  RG: $RESOURCE_GROUP"
          echo "  MySQL: $MYSQL_FQDN"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Azure Login
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}


    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # AKS Credentials
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ steps.get-infra.outputs.resource-group }} \
          --name ${{ steps.get-infra.outputs.aks-cluster-name }} \
          --admin \
          --overwrite-existing

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # ACR Login
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Login to ACR
      run: |
        az acr login --name $(echo "${{ steps.get-infra.outputs.acr-login-server }}" | cut -d'.' -f1)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Validate Frontend Build Env (CRITICAL FIX)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Validate NEXT_PUBLIC_API_URL
      run: |
        if [ -z "${{ secrets.NEXT_PUBLIC_API_URL }}" ]; then
          echo "âŒ NEXT_PUBLIC_API_URL secret is missing"
          exit 1
        fi
        echo "Using NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Auto-generate Dockerfiles
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Generate Backend Dockerfile
      run: |
        echo "Generating Backend Dockerfile"
        cat << 'EOF' > Dockerfile.backend
        FROM node:18-alpine
        WORKDIR /app
        COPY package*.json ./
        RUN npm ci --only=production || true
        COPY . .
        ENV NODE_ENV=production
        EXPOSE 3001
        CMD ["node", "index.js"]
        EOF

    - name: Generate Frontend Dockerfile
      env:
        NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
        FRONTEND_PATH: frontend
      run: |
        mkdir -p $FRONTEND_PATH
        if [ ! -f "$FRONTEND_PATH/Dockerfile" ]; then
          echo "ğŸ“ Creating production-ready Next.js Dockerfile..."
          cat > $FRONTEND_PATH/Dockerfile <<'EOF'
          FROM node:18-alpine AS deps
          RUN apk add --no-cache libc6-compat
          WORKDIR /app
          COPY package*.json ./
          RUN npm install --omit=dev

          FROM node:18-alpine AS builder
          WORKDIR /app
          ARG NEXT_PUBLIC_API_URL
          ENV NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL
          ENV NEXT_TELEMETRY_DISABLED=1
          ENV NODE_ENV=production
          COPY --from=deps /app/node_modules ./node_modules
          COPY . .
          RUN npm run build

          FROM node:18-alpine AS runner
          WORKDIR /app
          ENV NODE_ENV=production
          ENV NEXT_TELEMETRY_DISABLED=1
          RUN addgroup --system --gid 1001 nodejs
          RUN adduser --system --uid 1001 nextjs
          COPY --from=builder /app/package.json ./package.json
          COPY --from=builder /app/public ./public
          COPY --from=builder --chown=nextjs:nodejs /app/.next ./.next
          COPY --from=builder /app/node_modules ./node_modules
          USER nextjs
          EXPOSE 3000
          ENV PORT=3000
          ENV HOSTNAME=0.0.0.0
          CMD ["npm", "start"]
          EOF
        else
          echo "âœ… Dockerfile already exists"
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Build & Push Backend Image
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Build & Push Backend Image
      run: |
        docker build \
          -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }} \
          -f Dockerfile.backend .

        docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Build & Push Frontend Image (Next.js Safe)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Build & Push Frontend Image
      run: |
        docker build \
          --build-arg NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }} \
          -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }} \
          -f Dockerfile.frontend .

        docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }}
   
    - name: Verify Images in ACR
      run: |
          echo "ğŸ“¦ Verifying images in ACR..."
          az acr repository show-tags --name ${{ steps.get-infra.outputs.acr-name }} --repository book-review-backend
          az acr repository show-tags --name ${{ steps.get-infra.outputs.acr-name }} --repository book-review-frontend

  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push-images
    env:
      environment: ${{ github.event.inputs.environment }}

    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Assign AKS Cluster Admin Role
        run: |
          echo "ğŸ” Ensuring service principal has AKS admin access..."
          
          # Get the service principal object ID
          SP_OBJECT_ID=$(az ad sp show --id ${{ secrets.AZURE_CLIENT_ID }} --query id -o tsv)
          
          # Get AKS resource ID
          AKS_ID=$(az aks show \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --query id -o tsv)
          
          # Assign Azure Kubernetes Service Cluster Admin Role
          az role assignment create \
            --assignee $SP_OBJECT_ID \
            --role "Azure Kubernetes Service Cluster Admin Role" \
            --scope $AKS_ID \
            2>/dev/null || echo "Role assignment already exists or not needed"
          
          echo "âœ… Role assignment complete"
      
      
      - name: Get AKS Credentials
        run: |
          echo "âœ… Using infrastructure details from Terraform:"
          echo "  AKS: ${{ needs.build-and-push-images.outputs.aks-cluster-name }}"
          echo "  Resource Group: ${{ needs.build-and-push-images.outputs.resource-group }}"
          
          # Get AKS credentials with admin access (uses cluster certificates)
          # This bypasses Azure RBAC and works with service principal authentication
          az aks get-credentials \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --admin \
            --overwrite-existing
          
          echo "âœ… AKS credentials configured successfully with admin access"

      
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Update ConfigMap (DB Host from Terraform)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Update ConfigMap
        run: |
          sed -i "s|<MYSQL_FQDN>|${{ needs.build-and-push-images.outputs.mysql-fqdn }}|g" k8s/configmap.yaml
          kubectl apply -f k8s/configmap.yaml

      - name: Set MySQL FQDN
        id: get-mysql
        run: |
          MYSQL_FQDN="${{ needs.build-and-push-images.outputs.mysql-fqdn }}"
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT
          echo "âœ… MySQL FQDN from Terraform: $MYSQL_FQDN"
      

      - name: Update Kubernetes Manifests
        run: |
          # Extract ACR name from login server
          ACR_NAME=$(echo "${{ needs.build-and-push-images.outputs.acr-login-server }}" | cut -d'.' -f1)
          MYSQL_FQDN="${{ steps.get-mysql.outputs.mysql-fqdn }}"
          
          echo "ğŸ”„ Updating manifests with actual values..."
          echo "  ACR: $ACR_NAME"
          echo "  MySQL FQDN: $MYSQL_FQDN"
          
          if [ -z "$MYSQL_FQDN" ] || [ "$MYSQL_FQDN" == "null" ]; then
            echo "âŒ ERROR: MYSQL_FQDN is empty or null!"
            exit 1
          fi
        
          # Update ConfigMap with MySQL FQDN - use explicit string
          sed -i "s|database_host: \"<MYSQL_FQDN>\"|database_host: \"$MYSQL_FQDN\"|g" \
            ${{ env.K8S_PATH }}/configmaps/app-config.yaml  
        
          # Verify replacements
          echo ""
          echo "ğŸ“‹ Verification - ConfigMap database_host:"
          grep "database_host:" ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          echo ""
          echo "ğŸ“‹ Verification - Backend image:"
          grep "image:" ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml | head -1
          
          # Check if placeholder still exists
          if grep -q "<MYSQL_FQDN>" ${{ env.K8S_PATH }}/configmaps/app-config.yaml; then
            echo "âŒ ERROR: MYSQL_FQDN placeholder not replaced!"
            cat ${{ env.K8S_PATH }}/configmaps/app-config.yaml
            exit 1
          fi
          
          echo "âœ… Kubernetes manifests updated successfully"
      
      - name: Create Kubernetes Namespace
        run: |
          kubectl create namespace ${{  env.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=${{ env.NAMESPACE }}

      - name: Create Kubernetes Secrets
        run: |
          # Create or update database credentials and JWT secret
          kubectl create secret generic book-review-secrets \
            --from-literal=database_user=${{ secrets.MYSQL_ADMIN_USERNAME }} \
            --from-literal=database_password=${{ secrets.MYSQL_ADMIN_PASSWORD }} \
            --from-literal=jwt_secret=${{ secrets.JWT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "âœ… Secrets created/updated"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Deploy Backend
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy Backend
        run: |
          sed -i "s|<ACR_NAME>|$(echo '${{ needs.build-and-push-images.outputs.acr-login-server }}' | cut -d'.' -f1)|g" k8s/backend-deployment.yaml
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl rollout restart deployment/book-review-backend -n $NAMESPACE

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Deploy Frontend
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy Frontend
        run: |
          sed -i "s|<ACR_NAME>|$(echo '${{ needs.build-and-push-images.outputs.acr-login-server }}' | cut -d'.' -f1)|g" k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl rollout restart deployment/book-review-frontend -n $NAMESPACE

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Deploy Services & Ingress
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy Services & Ingress
        run: |
          kubectl apply -f k8s/services/backend-service.yaml
          kubectl apply -f k8s/services/frontend-service.yaml
          kubectl apply -f k8s/ingress.yaml

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Wait for Ingress IP
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Wait for Ingress IP
        run: |
          echo "Waiting for Ingress external IP..."
          for i in {1..30}; do
          INGRESS_IP=$(kubectl get ingress book-review-ingress -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$INGRESS_IP" ]; then
            echo "INGRESS_IP=$INGRESS_IP" >> $GITHUB_ENV
            break
          fi
          sleep 10
          done

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Deployment Summary
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deployment Summary
        run: |
          DEPLOY_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ DEPLOYMENT SUCCESSFULLY COMPLETED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Frontend:  http://$INGRESS_IP"
          echo "Backend:   http://$INGRESS_IP/api"
          echo ""
          echo "AKS Cluster:    ${{ needs.build-and-push-images.outputs.aks-cluster-name }}"
          echo "Resource Group:${{ needs.build-and-push-images.outputs.resource-group }}"
          echo "Namespace:     $NAMESPACE"
          echo "MySQL Server:  ${{ needs.build-and-push-images.outputs.mysql-fqdn }}"
          echo ""
          kubectl get pods -n $NAMESPACE
          kubectl get svc -n $NAMESPACE
          kubectl get ingress -n $NAMESPACE
name: Application Deployment

# Workflow Chain: Infrastructure Deploy â†’ Application Deploy (auto) â†’ Manual Destroy
# This workflow is automatically triggered by Infrastructure Deployment on success
# Can also be manually triggered for redeployment or updates

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      frontend_image_tag:
        description: 'Frontend Image Tag'
        required: false
        default: 'latest'
      backend_image_tag:
        description: 'Backend Image Tag'
        required: false
        default: 'latest'
      run_id:
        description: 'Infrastructure workflow run ID (auto-filled)'
        required: false
        type: string
      app_repository:
        description: 'Application GitHub Repository (e.g., owner/repo)'
        required: false
        default: 'pravinmishraaws/book-review-app'
        type: string
      app_branch:
        description: 'Application Repository Branch'
        required: false
        default: 'main'
        type: string

env:
  FRONTEND_PATH: './book-review-app/frontend'
  BACKEND_PATH: './book-review-app/backend'
  K8S_PATH: './k8s'

jobs:
  build-and-push-images:
    name: Build and Push Container Images
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    outputs:
      acr-login-server: ${{ steps.get-infra.outputs.acr-login-server }}
      aks-cluster-name: ${{ steps.get-infra.outputs.aks-cluster-name }}
      resource-group: ${{ steps.get-infra.outputs.resource-group }}
      mysql-fqdn: ${{ steps.get-infra.outputs.mysql-fqdn }}
      frontend-image: ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }}
      backend-image: ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state-${{ github.event.inputs.environment }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.inputs.run_id }}
          repository: ${{ github.repository }}
      
      - name: Fetch Application Code from Repository
        run: |
          APP_REPO="${{ github.event.inputs.app_repository || 'pravinmishraaws/book-review-app' }}"
          APP_BRANCH="${{ github.event.inputs.app_branch || 'main' }}"
          
          echo "ğŸ“¥ Fetching application code from repository..."
          echo "Repository: $APP_REPO"
          echo "Branch: $APP_BRANCH"
          
          # Clone the application repository
          git clone --branch $APP_BRANCH --depth 1 \
            https://github.com/$APP_REPO.git book-review-app
          
          echo "âœ… Application code fetched successfully"
          echo "ğŸ“ Directory structure:"
          ls -la book-review-app/
      
      - name: Verify Application Structure
        run: |
          echo "ğŸ” Verifying application structure..."
          
          if [ -d "${{ env.BACKEND_PATH }}" ]; then
            echo "âœ… Backend directory found"
            ls -la ${{ env.BACKEND_PATH }}/
          else
            echo "âš ï¸ Backend directory not found at ${{ env.BACKEND_PATH }}"
          fi
          
          if [ -d "${{ env.FRONTEND_PATH }}" ]; then
            echo "âœ… Frontend directory found"
            ls -la ${{ env.FRONTEND_PATH }}/
          else
            echo "âš ï¸ Frontend directory not found at ${{ env.FRONTEND_PATH }}"
          fi
      
      - name: Extract Infrastructure Details from Terraform
        id: get-infra
        run: |
          echo "ğŸ“‹ Extracting infrastructure details from Terraform outputs..."
          
          # Parse terraform outputs JSON
          ACR_NAME=$(jq -r '.acr_name.value' terraform-outputs.json)
          ACR_LOGIN_SERVER=$(jq -r '.acr_login_server.value' terraform-outputs.json)
          AKS_CLUSTER_NAME=$(jq -r '.aks_cluster_name.value' terraform-outputs.json)
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value' terraform-outputs.json)
          MYSQL_FQDN=$(jq -r '.mysql_fqdn.value' terraform-outputs.json)
          
          # Validate extracted values
          if [ -z "$ACR_NAME" ] || [ "$ACR_NAME" == "null" ]; then
            echo "âŒ Error: ACR name not found in Terraform outputs"
            exit 1
          fi
          
          # Export to outputs
          echo "acr-name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "aks-cluster-name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT
          
          echo "âœ… Infrastructure Details:"
          echo "  ACR: $ACR_NAME ($ACR_LOGIN_SERVER)"
          echo "  AKS: $AKS_CLUSTER_NAME"
          echo "  RG: $RESOURCE_GROUP"
          echo "  MySQL: $MYSQL_FQDN"
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: ACR Login
        run: |
          az acr login --name ${{ steps.get-infra.outputs.acr-name }}
      
      - name: Build and Push Backend Image
        run: |
          # Check if backend directory exists
          if [ ! -d "${{ env.BACKEND_PATH }}" ]; then
            echo "âš ï¸ Backend directory not found at ${{ env.BACKEND_PATH }}"
            echo "Creating a sample Dockerfile for demonstration..."
            mkdir -p ${{ env.BACKEND_PATH }}
            cat > ${{ env.BACKEND_PATH }}/Dockerfile <<EOF
          FROM node:18-alpine
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci --only=production || true
          COPY . .
          EXPOSE 8080
          CMD ["npm", "start"]
          EOF
          fi
          
          docker build -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }} \
            ${{ env.BACKEND_PATH }}
          
          docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }}
          
          echo "âœ… Backend image pushed successfully"
      
      - name: Build and Push Frontend Image
        run: |
          # Check if frontend directory exists
          if [ ! -d "${{ env.FRONTEND_PATH }}" ]; then
            echo "âš ï¸ Frontend directory not found at ${{ env.FRONTEND_PATH }}"
            echo "Creating a sample Dockerfile for demonstration..."
            mkdir -p ${{ env.FRONTEND_PATH }}
            cat > ${{ env.FRONTEND_PATH }}/Dockerfile <<EOF
          FROM nginx:alpine
          COPY . /usr/share/nginx/html
          EXPOSE 80
          CMD ["nginx", "-g", "daemon off;"]
          EOF
          else
            echo "âœ… Frontend directory found"
            
            # Check if Dockerfile exists, if not create a proper Next.js production Dockerfile
            if [ ! -f "${{ env.FRONTEND_PATH }}/Dockerfile" ]; then
              echo "ğŸ“ Creating production-ready Next.js Dockerfile..."
              cat > ${{ env.FRONTEND_PATH }}/Dockerfile <<'EOF'
          # Multi-stage build for Next.js application
          FROM node:18-alpine AS deps
          RUN apk add --no-cache libc6-compat
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci
          
          FROM node:18-alpine AS builder
          WORKDIR /app
          COPY --from=deps /app/node_modules ./node_modules
          COPY . .
          
          # Set environment variables for build
          ENV NEXT_TELEMETRY_DISABLED=1
          ENV NODE_ENV=production
          
          # Build the application
          RUN npm run build
          
          FROM node:18-alpine AS runner
          WORKDIR /app
          ENV NODE_ENV=production
          ENV NEXT_TELEMETRY_DISABLED=1
          
          RUN addgroup --system --gid 1001 nodejs
          RUN adduser --system --uid 1001 nextjs
          
          # Copy package files
          COPY --from=builder /app/package.json ./package.json
          
          # Copy public assets (ensured to exist in builder)
          COPY --from=builder /app/public ./public
          
          # Copy .next folder (includes all build output and config)
          COPY --from=builder --chown=nextjs:nodejs /app/.next ./.next
          
          # Copy node_modules for runtime dependencies
          COPY --from=builder /app/node_modules ./node_modules
          
          USER nextjs
          EXPOSE 3000
          ENV PORT=3000
          ENV HOSTNAME=0.0.0.0
          
          # Start Next.js in production mode
          CMD ["npm", "start"]
          EOF
            else
              echo "ğŸ“ Dockerfile exists, checking if it builds Next.js..."
              # Check if Dockerfile includes build step
              if ! grep -q "npm run build\|next build" "${{ env.FRONTEND_PATH }}/Dockerfile"; then
                echo "âš ï¸ Existing Dockerfile may not build Next.js. Creating optimized version..."
                mv "${{ env.FRONTEND_PATH }}/Dockerfile" "${{ env.FRONTEND_PATH }}/Dockerfile.original"
                cat > ${{ env.FRONTEND_PATH }}/Dockerfile <<'EOF'
          # Multi-stage build for Next.js application
          FROM node:18-alpine AS deps
          RUN apk add --no-cache libc6-compat
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci
          
          FROM node:18-alpine AS builder
          WORKDIR /app
          COPY --from=deps /app/node_modules ./node_modules
          COPY . .
          
          # Set environment variables for build
          ENV NEXT_TELEMETRY_DISABLED=1
          ENV NODE_ENV=production
          
          # Ensure public directory exists (even if empty)
          RUN mkdir -p public
          
          # Build the application
          RUN npm run build
          
          FROM node:18-alpine AS runner
          WORKDIR /app
          ENV NODE_ENV=production
          ENV NEXT_TELEMETRY_DISABLED=1
          
          RUN addgroup --system --gid 1001 nodejs
          RUN adduser --system --uid 1001 nextjs
          
          # Copy package files
          COPY --from=builder /app/package.json ./package.json
          
          # Copy public assets (ensured to exist in builder)
          COPY --from=builder /app/public ./public
          
          # Copy .next folder (includes all build output and config)
          COPY --from=builder --chown=nextjs:nodejs /app/.next ./.next
          
          # Copy node_modules for runtime dependencies
          COPY --from=builder /app/node_modules ./node_modules
          
          USER nextjs
          EXPOSE 3000
          ENV PORT=3000
          ENV HOSTNAME=0.0.0.0
          
          # Start Next.js in production mode
          CMD ["npm", "start"]
          EOF
              fi
            fi
          fi
          
          echo "ğŸ—ï¸ Building frontend Docker image..."
          docker build -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }} \
            ${{ env.FRONTEND_PATH }}
          
          echo "ğŸ“¤ Pushing frontend image to ACR..."
          docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }}
          
          echo "âœ… Frontend image pushed successfully"
      
      - name: Verify Images in ACR
        run: |
          echo "ğŸ“¦ Verifying images in ACR..."
          az acr repository show-tags --name ${{ steps.get-infra.outputs.acr-name }} --repository book-review-backend
          az acr repository show-tags --name ${{ steps.get-infra.outputs.acr-name }} --repository book-review-frontend

  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push-images
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Assign AKS Cluster Admin Role
        run: |
          echo "ğŸ” Ensuring service principal has AKS admin access..."
          
          # Get the service principal object ID
          SP_OBJECT_ID=$(az ad sp show --id ${{ secrets.AZURE_CLIENT_ID }} --query id -o tsv)
          
          # Get AKS resource ID
          AKS_ID=$(az aks show \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --query id -o tsv)
          
          # Assign Azure Kubernetes Service Cluster Admin Role
          az role assignment create \
            --assignee $SP_OBJECT_ID \
            --role "Azure Kubernetes Service Cluster Admin Role" \
            --scope $AKS_ID \
            2>/dev/null || echo "Role assignment already exists or not needed"
          
          echo "âœ… Role assignment complete"
      
      - name: Install kubelogin
        run: |
          echo "ğŸ“¦ Installing kubelogin for Azure AD authentication..."
          
          # Download and install kubelogin using the correct URL format
          KUBELOGIN_VERSION="v0.1.4"
          
          # Download the zip file with error checking
          echo "Downloading kubelogin ${KUBELOGIN_VERSION}..."
          curl -fsSL "https://github.com/Azure/kubelogin/releases/download/${KUBELOGIN_VERSION}/kubelogin-linux-amd64.zip" -o kubelogin.zip
          
          # Verify the download
          if [ ! -f kubelogin.zip ] || [ ! -s kubelogin.zip ]; then
            echo "âŒ Download failed or file is empty"
            exit 1
          fi
          
          # Unzip and install
          unzip -o kubelogin.zip
          sudo install -m 755 bin/linux_amd64/kubelogin /usr/local/bin/kubelogin
          
          # Clean up
          rm -rf kubelogin.zip bin/
          
          # Verify installation
          kubelogin --version
          
          echo "âœ… kubelogin installed successfully"
      
      - name: Get AKS Credentials
        run: |
          echo "âœ… Using infrastructure details from Terraform:"
          echo "  AKS: ${{ needs.build-and-push-images.outputs.aks-cluster-name }}"
          echo "  Resource Group: ${{ needs.build-and-push-images.outputs.resource-group }}"
          
          # Get AKS credentials with admin access (uses cluster certificates)
          # This bypasses Azure RBAC and works with service principal authentication
          az aks get-credentials \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --admin \
            --overwrite-existing
          
          echo "âœ… AKS credentials configured successfully with admin access"
      
      - name: Set MySQL FQDN
        id: get-mysql
        run: |
          MYSQL_FQDN="${{ needs.build-and-push-images.outputs.mysql-fqdn }}"
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT
          echo "âœ… MySQL FQDN from Terraform: $MYSQL_FQDN"
      
      - name: Update Kubernetes Manifests
        run: |
          # Extract ACR name from login server
          ACR_NAME=$(echo "${{ needs.build-and-push-images.outputs.acr-login-server }}" | cut -d'.' -f1)
          MYSQL_FQDN="${{ steps.get-mysql.outputs.mysql-fqdn }}"
          
          echo "ğŸ”„ Updating manifests with actual values..."
          echo "  ACR: $ACR_NAME"
          echo "  MySQL FQDN: $MYSQL_FQDN"
          
          if [ -z "$MYSQL_FQDN" ] || [ "$MYSQL_FQDN" == "null" ]; then
            echo "âŒ ERROR: MYSQL_FQDN is empty or null!"
            exit 1
          fi
          
          # Update backend deployment
          sed -i "s|<ACR_NAME>\.azurecr\.io/book-review-backend:latest|${{ needs.build-and-push-images.outputs.backend-image }}|g" \
            ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml
          
          # Update frontend deployment  
          sed -i "s|<ACR_NAME>\.azurecr\.io/book-review-frontend:latest|${{ needs.build-and-push-images.outputs.frontend-image }}|g" \
            ${{ env.K8S_PATH }}/deployments/frontend-deployment.yaml
          
          # Update ConfigMap with MySQL FQDN - use explicit string
          sed -i "s|database_host: \"<MYSQL_FQDN>\"|database_host: \"$MYSQL_FQDN\"|g" \
            ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          # Verify replacements
          echo ""
          echo "ğŸ“‹ Verification - ConfigMap database_host:"
          grep "database_host:" ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          echo ""
          echo "ğŸ“‹ Verification - Backend image:"
          grep "image:" ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml | head -1
          
          # Check if placeholder still exists
          if grep -q "<MYSQL_FQDN>" ${{ env.K8S_PATH }}/configmaps/app-config.yaml; then
            echo "âŒ ERROR: MYSQL_FQDN placeholder not replaced!"
            cat ${{ env.K8S_PATH }}/configmaps/app-config.yaml
            exit 1
          fi
          
          echo "âœ… Kubernetes manifests updated successfully"
      
      - name: Create Kubernetes Namespace
        run: |
          kubectl create namespace book-review-${{ github.event.inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=book-review-${{ github.event.inputs.environment }}
      
      - name: Create Kubernetes Secrets
        run: |
          # Create or update database credentials and JWT secret
          kubectl create secret generic book-review-secrets \
            --from-literal=database_user=${{ secrets.MYSQL_ADMIN_USERNAME }} \
            --from-literal=database_password=${{ secrets.MYSQL_ADMIN_PASSWORD }} \
            --from-literal=jwt_secret=${{ secrets.JWT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "âœ… Secrets created/updated"
      
      - name: Deploy ConfigMap
        run: |
          # Show the ConfigMap before applying
          echo "ğŸ“‹ ConfigMap content:"
          cat ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          kubectl apply -f ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          echo "âœ… ConfigMap deployed"
          
          # Verify what was actually deployed
          echo ""
          echo "ğŸ“‹ Deployed ConfigMap verification:"
          kubectl get configmap book-review-config -o yaml
      
      - name: Deploy Backend
        run: |
          kubectl apply -f ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml
          kubectl apply -f ${{ env.K8S_PATH }}/services/backend-service.yaml
          
          # Force restart to pull latest image (in case tag hasn't changed)
          echo "ğŸ”„ Forcing rollout restart to ensure latest image is used..."
          kubectl rollout restart deployment/book-review-backend
          
          echo "â³ Waiting for backend deployment to roll out..."
          kubectl rollout status deployment/book-review-backend --timeout=300s || echo "âš ï¸ Rollout timeout - check debug output"
          
          echo ""
          echo "ğŸ“Š Current backend pod status:"
          kubectl get pods -l component=backend
          
          echo "âœ… Backend deployment applied"
      
      - name: Debug Backend Deployment
        if: always()
        continue-on-error: true
        run: |
          set +e  # Don't exit on error
          
          echo "ğŸ” Backend Pod Status:"
          kubectl get pods -l component=backend -o wide 2>/dev/null || echo "No backend pods found"
          
          echo ""
          echo "ğŸ“‹ Backend Deployment Status:"
          kubectl get deployment book-review-backend 2>/dev/null || echo "Deployment not found"
          
          echo ""
          echo "ğŸ“‹ Backend ReplicaSet Status:"
          kubectl get rs -l app=book-review,component=backend 2>/dev/null || echo "No ReplicaSets found"
          
          echo ""
          echo "ğŸ“‹ Recent Events (all):"
          kubectl get events --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo "No events found"
          
          echo ""
          echo "ğŸ“œ Backend Pod Logs (if any exist):"
          PODS=$(kubectl get pod -l component=backend -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
          if [ -n "$PODS" ]; then
            for POD in $(echo $PODS | tr ' ' '\n' | head -3); do
              echo ""
              echo "=== Logs from $POD ==="
              kubectl logs $POD --tail=50 2>/dev/null || echo "Failed to get logs from $POD"
            done
          else
            echo "No backend pods available for logs"
          fi
          
          echo ""
          echo "ğŸ“‹ ConfigMap Values:"
          kubectl get configmap book-review-config -o yaml 2>/dev/null | grep -A 5 "data:" || echo "ConfigMap not found"
          
          exit 0  # Always succeed
      
      - name: Deploy Frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
        run: |
          echo "Injecting NEXT_PUBLIC_API_URL: $NEXT_PUBLIC_API_URL"
          # Optionally, print to verify (remove in production)
          kubectl apply -f ${{ env.K8S_PATH }}/deployments/frontend-deployment.yaml
          kubectl apply -f ${{ env.K8S_PATH }}/services/frontend-service.yaml
          
          # Force restart to pull latest image (in case tag hasn't changed)
          echo "ğŸ”„ Forcing rollout restart to ensure latest image is used..."
          kubectl rollout restart deployment/book-review-frontend
          
          echo "â³ Waiting for frontend deployment to roll out..."
          kubectl rollout status deployment/book-review-frontend --timeout=300s || echo "âš ï¸ Rollout timeout - check debug output"
          
          echo ""
          echo "ğŸ“Š Current frontend pod status:"
          kubectl get pods -l component=frontend
          
          echo "âœ… Frontend deployment applied"
      
      - name: Deploy Ingress
        run: |
          echo "ğŸŒ Deploying Ingress resource..."
          kubectl apply -f ${{ env.K8S_PATH }}/ingress.yaml
          echo "âœ… Ingress resource applied"
          
      - name: Wait for Ingress IP Assignment
        id: ingress-ip
        run: |
          echo "â³ Waiting for Ingress Controller to assign external IP..."
          
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get ingress book-review-ingress -n book-review-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [ -n "$INGRESS_IP" ] && [ "$INGRESS_IP" != "null" ]; then
              echo "âœ… Ingress External IP assigned: $INGRESS_IP"
              echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
              echo "ip_assigned=true" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "Attempt $i/30: Waiting for IP assignment..."
            sleep 10
          done
          
          if [ -z "$INGRESS_IP" ] || [ "$INGRESS_IP" == "null" ]; then
            echo "âš ï¸ Ingress IP not yet assigned after 5 minutes"
            echo "ip_assigned=false" >> $GITHUB_OUTPUT
            echo "ingress_ip=pending" >> $GITHUB_OUTPUT
          fi
          
          echo ""
          echo "ğŸ“‹ Ingress Status:"
          kubectl get ingress -n book-review-dev
          kubectl describe ingress book-review-ingress -n book-review-dev
      
      - name: Update CORS Origins with Ingress IP
        if: steps.ingress-ip.outputs.ip_assigned == 'true'
        run: |
          INGRESS_IP="${{ steps.ingress-ip.outputs.ingress_ip }}"
          
          echo "ğŸ”„ Updating ALLOWED_ORIGINS with Ingress IP: $INGRESS_IP"
          
          # Get current ConfigMap
          kubectl get configmap book-review-config -n book-review-dev -o yaml > /tmp/configmap.yaml
          
          # Update allowed_origins to include Ingress IP
          sed -i "s|allowed_origins: .*|allowed_origins: \"http://$INGRESS_IP,http://localhost:3000\"|g" /tmp/configmap.yaml
          
          # Apply updated ConfigMap
          kubectl apply -f /tmp/configmap.yaml
          
          echo "âœ… ALLOWED_ORIGINS updated to include http://$INGRESS_IP"
          
          # Restart backend to pick up new config
          kubectl rollout restart deployment/book-review-backend -n book-review-dev
          
          echo "ğŸ”„ Backend restarted to apply new CORS configuration"
      
      - name: Debug Frontend Issues
        if: always()
        run: |
          echo "ğŸ” Checking frontend pod logs..."
          PODS=$(kubectl get pod -l component=frontend -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
          if [ -n "$PODS" ]; then
            for POD in $(echo $PODS | tr ' ' '\n' | head -3); do
              echo ""
              echo "=== Logs from $POD ==="
              kubectl logs $POD --tail=100 2>/dev/null || echo "Failed to get logs from $POD"
              echo ""
              echo "=== Previous logs (if crashed) ==="
              kubectl logs $POD --previous --tail=50 2>/dev/null || echo "No previous logs"
            done
          else
            echo "No frontend pods available for logs"
          fi
          
          echo ""
          echo "ğŸ“‹ Frontend Pod Events:"
          kubectl get events --field-selector involvedObject.name!='' | grep frontend || echo "No frontend events"
      
      - name: Verify Application Health
        if: steps.ingress-ip.outputs.ip_assigned == 'true'
        run: |
          INGRESS_IP="${{ steps.ingress-ip.outputs.ingress_ip }}"
          
          echo "ğŸ” Verifying application health via Ingress..."
          echo ""
          
          # Test frontend through Ingress
          echo "Testing frontend access..."
          if kubectl run test-frontend-health --rm -i --restart=Never --image=curlimages/curl -n book-review-dev -- \
            curl -s -o /dev/null -w "%{http_code}" http://ingress-nginx-controller.ingress-nginx.svc.cluster.local/ | grep -q "200"; then
            echo "âœ… Frontend is healthy"
          else
            echo "âš ï¸ Frontend health check inconclusive"
          fi
          
          # Test backend API through Ingress
          echo "Testing backend API access..."
          if kubectl run test-backend-health --rm -i --restart=Never --image=curlimages/curl -n book-review-dev -- \
            curl -s http://ingress-nginx-controller.ingress-nginx.svc.cluster.local/api/books | grep -q "title"; then
            echo "âœ… Backend API is healthy"
          else
            echo "âš ï¸ Backend API health check inconclusive"
          fi
          
          echo ""
          echo "âœ… Application deployed successfully!"
          echo "ğŸŒ Application URL: http://$INGRESS_IP"
          echo "ğŸ”— Backend API: http://$INGRESS_IP/api"
      
      - name: Deployment Summary
        run: |
          INGRESS_IP="${{ steps.ingress-ip.outputs.ingress_ip }}"
          NAMESPACE="book-review-${{ github.event.inputs.environment }}"
          RESOURCE_GROUP="${{ needs.build-and-push-images.outputs.resource-group }}"
          AKS_CLUSTER="${{ needs.build-and-push-images.outputs.aks-cluster-name }}"
          ACR_SERVER="${{ needs.build-and-push-images.outputs.acr-login-server }}"
          MYSQL_FQDN="${{ needs.build-and-push-images.outputs.mysql-fqdn }}"
          
          # Get deployment timestamp
          DEPLOY_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          # Count resources
          POD_COUNT=$(kubectl get pods -n $NAMESPACE --no-headers | wc -l)
          RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Running --no-headers | wc -l)
          
          # Generate detailed GitHub Actions Step Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ğŸš€ Book Review Application - Deployment Summary
          
          ---
          
          ## ğŸ“‹ Deployment Information
          
          | Property | Value |
          |----------|-------|
          | **Environment** | \`${{ github.event.inputs.environment }}\` |
          | **Deployment Time** | $DEPLOY_TIME |
          | **Deployed By** | @${{ github.actor }} |
          | **Workflow Run** | [\#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          | **Git Commit** | [\`${GITHUB_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |
          
          ---
          
          ## ğŸŒ Application Access
          
          ### Primary Access
          - **ğŸŒ Frontend Application**: http://$INGRESS_IP
          - **ğŸ”Œ Backend API**: http://$INGRESS_IP/api
          - **ğŸ“š API Documentation**: http://$INGRESS_IP/api/docs *(if available)*
          
          ### Alternative Access (Port-Forward)
          If external IP is not accessible:
          \`\`\`bash
          kubectl port-forward -n ingress-nginx svc/ingress-nginx-controller 8080:80
          # Then access: http://localhost:8080
          \`\`\`
          
          ---
          
          ## ğŸ—ï¸ Infrastructure Details
          
          | Component | Value |
          |-----------|-------|
          | **Azure Region** | Australia Central |
          | **Resource Group** | \`$RESOURCE_GROUP\` |
          | **AKS Cluster** | \`$AKS_CLUSTER\` |
          | **Namespace** | \`$NAMESPACE\` |
          | **Ingress Controller** | NGINX Ingress v1.8.2 |
          | **Ingress IP** | \`$INGRESS_IP\` |
          | **Container Registry** | \`$ACR_SERVER\` |
          | **MySQL Server** | \`$MYSQL_FQDN\` |
          
          ---
          
          ## ğŸ“¦ Deployed Container Images
          
          ### Backend Service
          \`\`\`
          ${{ needs.build-and-push-images.outputs.backend-image }}
          \`\`\`
          
          ### Frontend Service
          \`\`\`
          ${{ needs.build-and-push-images.outputs.frontend-image }}
          \`\`\`
          
          ---
          
          ## ğŸ“Š Resource Status
          
          **Total Pods**: $POD_COUNT | **Running**: $RUNNING_PODS
          
          ### ğŸŸ¢ Pods
          \`\`\`
          $(kubectl get pods -n $NAMESPACE -o wide)
          \`\`\`
          
          ### ğŸ”Œ Services
          \`\`\`
          $(kubectl get svc -n $NAMESPACE -o wide)
          \`\`\`
          
          ### ğŸŒ Ingress
          \`\`\`
          $(kubectl get ingress -n $NAMESPACE -o wide)
          \`\`\`
          
          ### âš™ï¸ ConfigMaps
          \`\`\`
          $(kubectl get configmap -n $NAMESPACE | grep book-review)
          \`\`\`
          
          ### ğŸ” Secrets
          \`\`\`
          $(kubectl get secrets -n $NAMESPACE | grep book-review)
          \`\`\`
          
          ---
          
          ## ğŸ”§ Management Commands
          
          ### Access Cluster
          \`\`\`bash
          # Get AKS credentials
          az aks get-credentials \\
            --resource-group $RESOURCE_GROUP \\
            --name $AKS_CLUSTER \\
            --admin
          
          # Set default namespace
          kubectl config set-context --current --namespace=$NAMESPACE
          \`\`\`
          
          ### View Logs
          \`\`\`bash
          # Frontend logs
          kubectl logs -n $NAMESPACE -l component=frontend --tail=100 -f
          
          # Backend logs
          kubectl logs -n $NAMESPACE -l component=backend --tail=100 -f
          
          # Ingress Controller logs
          kubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller --tail=100 -f
          \`\`\`
          
          ### Debug Commands
          \`\`\`bash
          # Check pod status
          kubectl get pods -n $NAMESPACE -o wide
          
          # Describe a pod (replace POD_NAME)
          kubectl describe pod <POD_NAME> -n $NAMESPACE
          
          # Execute shell in pod
          kubectl exec -it <POD_NAME> -n $NAMESPACE -- /bin/sh
          
          # Check Ingress details
          kubectl describe ingress book-review-ingress -n $NAMESPACE
          
          # View ConfigMap
          kubectl get configmap book-review-config -n $NAMESPACE -o yaml
          
          # Test internal connectivity
          kubectl run test-curl --rm -i --restart=Never --image=curlimages/curl -n $NAMESPACE -- curl -v http://book-review-frontend:3000
          \`\`\`
          
          ### Restart Deployments
          \`\`\`bash
          # Restart backend
          kubectl rollout restart deployment/book-review-backend -n $NAMESPACE
          
          # Restart frontend
          kubectl rollout restart deployment/book-review-frontend -n $NAMESPACE
          
          # Check rollout status
          kubectl rollout status deployment/book-review-backend -n $NAMESPACE
          kubectl rollout status deployment/book-review-frontend -n $NAMESPACE
          \`\`\`
          
          ### Scale Resources
          \`\`\`bash
          # Scale backend replicas
          kubectl scale deployment/book-review-backend -n $NAMESPACE --replicas=3
          
          # Scale frontend replicas
          kubectl scale deployment/book-review-frontend -n $NAMESPACE --replicas=3
          \`\`\`
          
          ---
          
          ## ğŸ” Monitoring & Troubleshooting
          
          ### Health Checks
          \`\`\`bash
          # Test frontend health
          curl -I http://$INGRESS_IP/
          
          # Test backend API health
          curl http://$INGRESS_IP/api/books
          
          # Test from within cluster
          kubectl run test-health --rm -i --restart=Never --image=curlimages/curl -n $NAMESPACE -- \\
            curl -v http://ingress-nginx-controller.ingress-nginx.svc.cluster.local/
          \`\`\`
          
          ### View Events
          \`\`\`bash
          # Recent events in namespace
          kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -20
          
          # Watch events in real-time
          kubectl get events -n $NAMESPACE --watch
          \`\`\`
          
          ### Resource Usage
          \`\`\`bash
          # Pod resource usage
          kubectl top pods -n $NAMESPACE
          
          # Node resource usage
          kubectl top nodes
          \`\`\`
          
          ---
          
          ## âš ï¸ Known Issues & Solutions
          
          ### Issue: External IP Timeout
          **Symptom**: Cannot access http://$INGRESS_IP from browser  
          **Solution**: Check NSG rules in Azure Portal for node resource group (MC_*)
          \`\`\`bash
          # Add NSG rule via Azure CLI
          az network nsg rule create \\
            --resource-group MC_${RESOURCE_GROUP}_${AKS_CLUSTER}_australiacentral \\
            --nsg-name aks-agentpool-*-nsg \\
            --name AllowIngressTraffic \\
            --priority 100 \\
            --source-address-prefixes Internet \\
            --destination-port-ranges 80 443 30000-32767 \\
            --access Allow \\
            --protocol Tcp
          \`\`\`
          
          ### Issue: Pods Not Starting
          **Symptom**: Pods stuck in Pending or CrashLoopBackOff  
          **Solution**: Check pod events and logs
          \`\`\`bash
          kubectl describe pod <POD_NAME> -n $NAMESPACE
          kubectl logs <POD_NAME> -n $NAMESPACE --previous
          \`\`\`
          
          ### Issue: Database Connection Errors
          **Symptom**: Backend logs show MySQL connection errors  
          **Solution**: Verify ConfigMap has correct MySQL FQDN and secrets are set
          \`\`\`bash
          # Check ConfigMap
          kubectl get configmap book-review-config -n $NAMESPACE -o yaml | grep database_host
          
          # Verify secrets exist
          kubectl get secret book-review-secrets -n $NAMESPACE
          \`\`\`
          
          ---
          
          ## ğŸ“ Support Resources
          
          - **Azure Portal**: [Resource Group](${{ github.server_url }}/${{ github.repository }})
          - **GitHub Repository**: [${{ github.repository }}](${{ github.server_url }}/${{ github.repository }})
          - **Workflow Runs**: [Actions](${{ github.server_url }}/${{ github.repository }}/actions)
          - **Kubernetes Dashboard**: Deploy with \`kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml\`
          
          ---
          
          ## âœ… Next Steps
          
          1. **Verify Application Access**: Test the frontend at http://$INGRESS_IP
          2. **Test API Endpoints**: Verify backend API at http://$INGRESS_IP/api/books
          3. **Monitor Logs**: Check application logs for any errors
          4. **Configure DNS**: *(Optional)* Set up custom domain name for the application
          5. **Enable SSL/TLS**: *(Optional)* Configure HTTPS with cert-manager
          6. **Set Up Monitoring**: *(Optional)* Configure Application Insights or Prometheus
          
          ---
          
          **ğŸ“… Deployment completed at**: $DEPLOY_TIME  
          **ğŸ¯ Status**: ${{ job.status }}
          
          EOF
          
          # Detailed Console Output
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "                    ğŸ‰ DEPLOYMENT SUCCESSFULLY COMPLETED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“‹ DEPLOYMENT INFORMATION"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  Environment:        ${{ github.event.inputs.environment }}"
          echo "  Deployment Time:    $DEPLOY_TIME"
          echo "  Deployed By:        ${{ github.actor }}"
          echo "  Workflow Run:       #${{ github.run_number }}"
          echo "  Git Commit:         ${GITHUB_SHA:0:7}"
          echo ""
          echo "ğŸŒ APPLICATION ACCESS"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  Frontend:           http://$INGRESS_IP"
          echo "  Backend API:        http://$INGRESS_IP/api"
          echo "  API Documentation:  http://$INGRESS_IP/api/docs"
          echo ""
          echo "  ğŸ“Œ Alternative Access (if external IP blocked):"
          echo "     kubectl port-forward -n ingress-nginx svc/ingress-nginx-controller 8080:80"
          echo "     Then access: http://localhost:8080"
          echo ""
          echo "ğŸ—ï¸  INFRASTRUCTURE DETAILS"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  Azure Region:       Australia Central"
          echo "  Resource Group:     $RESOURCE_GROUP"
          echo "  AKS Cluster:        $AKS_CLUSTER"
          echo "  Namespace:          $NAMESPACE"
          echo "  Ingress Controller: NGINX Ingress v1.8.2"
          echo "  Ingress IP:         $INGRESS_IP"
          echo "  Container Registry: $ACR_SERVER"
          echo "  MySQL Server:       $MYSQL_FQDN"
          echo ""
          echo "ğŸ“¦ DEPLOYED IMAGES"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  Backend:  ${{ needs.build-and-push-images.outputs.backend-image }}"
          echo "  Frontend: ${{ needs.build-and-push-images.outputs.frontend-image }}"
          echo ""
          echo "ğŸ“Š RESOURCE STATUS"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  Total Pods:    $POD_COUNT"
          echo "  Running Pods:  $RUNNING_PODS"
          echo "  Services:      $(kubectl get svc -n $NAMESPACE --no-headers | wc -l)"
          echo "  Ingress:       1 Active"
          echo ""
          echo "Pods:"
          kubectl get pods -n $NAMESPACE -o wide
          echo ""
          echo "Services:"
          kubectl get svc -n $NAMESPACE
          echo ""
          echo "Ingress:"
          kubectl get ingress -n $NAMESPACE
          echo ""
          echo "ğŸ”§ QUICK ACCESS COMMANDS"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  # Get cluster credentials"
          echo "  az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_CLUSTER --admin"
          echo ""
          echo "  # View logs"
          echo "  kubectl logs -n $NAMESPACE -l component=frontend --tail=50"
          echo "  kubectl logs -n $NAMESPACE -l component=backend --tail=50"
          echo ""
          echo "  # Restart deployments"
          echo "  kubectl rollout restart deployment/book-review-backend -n $NAMESPACE"
          echo "  kubectl rollout restart deployment/book-review-frontend -n $NAMESPACE"
          echo ""
          echo "  # Test application health"
          echo "  curl -I http://$INGRESS_IP/"
          echo "  curl http://$INGRESS_IP/api/books"
          echo ""
          echo "âš ï¸  TROUBLESHOOTING"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "  If external IP times out, add NSG rule:"
          echo "  az network nsg rule create \\"
          echo "    --resource-group MC_${RESOURCE_GROUP}_${AKS_CLUSTER}_australiacentral \\"
          echo "    --nsg-name aks-agentpool-*-nsg \\"
          echo "    --name AllowIngressTraffic \\"
          echo "    --priority 100 \\"
          echo "    --source-address-prefixes Internet \\"
          echo "    --destination-port-ranges 80 443 30000-32767 \\"
          echo "    --access Allow --protocol Tcp"
          echo ""
          echo "  Check pod status:"
          echo "  kubectl describe pod <POD_NAME> -n $NAMESPACE"
          echo "  kubectl logs <POD_NAME> -n $NAMESPACE"
          echo ""
          echo "  View events:"
          echo "  kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -20"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Deployment Status: SUCCESS"
          echo "ğŸ“– Full deployment summary available in GitHub Actions job summary above"
          echo "ğŸ”— Workflow URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
